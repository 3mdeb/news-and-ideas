---
title: TrenchBoot AEM gains support for UEFI installations
abstract: 'A feature craved by many is finally here.
          AEM can now be used with Qubes OS installed under UEFI.
		  Oh, and some automated testing. But mostly UEFI.'
cover: /covers/trenchboot-logo.png
author: krystian.hebel
layout: post
published: true
date: 2025-05-05
archives: "2025"

tags:
  - QubesOS
  - TrenchBoot
  - GRUB2
  - Xen
  - Testing
categories:
  - Firmware
  - Bootloader
  - Hypervisor
  - OS Dev
  - Security

---

## What's new in TrenchBoot AEM?

Adding support for UEFI installations was the main goal of this part of the
project [funded by NLnet foundation](https://nlnet.nl/project/TrenchBoot-AEM-UEFI/).
An approach similar to that of Linux (which is currently being upstreamed
TBD: LINK) was used. Even though this isn't how Xen is normally booted with
Qubes OS, it gets the job done.

Second, but not at all less important objective was to ensure that we don't
break existing implementation for legacy systems. In order to do so, we've
implemented automated tests to catch any misbehavior early, while simultaneously
saving time that we would have to spend installing and reinstalling Qubes OS and
AEM packages. Final bits and pieces are still being polished, but we believe
that this work may be a decent foundation for fully automatic tests in the
future.

The progress has been being logged in [this milestone on GitHub](https://github.com/TrenchBoot/trenchboot-issues/milestone/11?closed=1),
as well as in tasks and issues linked within.

Next sections describe some of the implementation details, as well as history
and rationale for design decisions made along the way. If you're not interested
in those and just want to test AEM for yourself, skip directly to [installation
instructions](#installation-instructions).

## UEFI implementation

There are no significant changes on OS side when it comes to UEFI vs legacy
booting, the only parts that are different are instructions for GRUB
installation, and how `grub.cfg` is created. Users won't even notice the latter,
as this is done automatically on package installation and upgrade.

Main difference is in how Xen is started. Without AEM, Qubes uses Multiboot2
protocol for both legacy and UEFI boot. The only difference is that GRUB for
UEFI parses and handles [EFI boot services tag](https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html#EFI-boot-services-tag)
by:

- not terminating UEFI boot services, and passing the information that they
  weren't terminated in Multiboot2 tag
- not passing some of the data that the launched payload is supposed to obtain
  by itself (memory map, among other things)
- using different entry point
- passing UEFI system table and image handle pointers in dedicated MB2 tags

In case of legacy boot, EFI boot services tag in image header is simply ignored,
and GRUB populates all the data payload may need in MB2 tags. As we can't use
UEFI boot services (they are not measured in the chain rooted in DRTM), we
started by testing what would happen on UEFI if the bootloader simply ignored
this tag if `slaunch` is used. We quickly discovered that Xen ignores some of
MB2 tags and tries to obtain the data "the old way" - by scanning specific
regions of memory in search of some structure.

An example of such structure is ACPI Root System Description Pointer (RSDP),
which points to the rest of ACPI tables. Depending on how the system is booted,
it can be found in one of these ways:

- on legacy BIOS, it is located somewhere in the low memory, which must be
  scanned in search for magic number in the header (this is what Xen on legacy
  does),
- on UEFI, it can be obtained with the help of boot services and system table
  pointer (this is what Xen on UEFI does),
- a copy of RSDP is stored in MB2 tag, and GRUB is responsible for obtaining it
  using one of the above mechanisms, depending on environment (Xen doesn't use
  it).

To address this problem, and probably similar one with SMBIOS later on, it was
decided that a solution similar to what was requested by Linux maintainers for
that system will be used. In that approach, kernel (be it Linux or Xen) is first
started using normal UEFI entry point (so not MB2 in case of Xen), allowed to
get everything it needs from boot services, and then jumping to Slaunch stub
implemented and exposed by GRUB.

This required changes both in GRUB as well as in Xen. Because `chainloader` is
used instead of `multiboot2` command, it also entailed modifications to
`anti-evil-maid` package, which is what is responsible for adding AEM entries in
`grub.cfg`. All of the changes can be found in following PRs:

- TBD: links (w/o Dasharo, including upstream)

## Testing

Each time new code is added, it should be tested. On top of that, we wanted to
make sure legacy boot still works after adding support for UEFI. Everything had
to be done for both Intel and AMD platforms, for TPM 1.2 and 2.0. This already
gives 8 distinctive configurations, which already is beyond what could be tested
manually in a reasonable amount of time, so automated tests had to be created.

Qubes OS is [tested with openQA](https://openqa.qubes-os.org), so this is what
is used to test AEM. We even reuse existing test that installs the system, to
make sure each of the follow-up steps are started from the same state. [Hardware
setup was described in earlier post](https://blog.3mdeb.com/2023/2023-12-22-qubesos-hw-testing/),
it was extended to cover more platforms. Some of the steps are specific to
platform, those are described in [our fork of `openqa-tests-qubesos` repository](https://github.com/3mdeb/openqa-tests-qubesos/tree/3mdeb-lab/generalhw).

Since tests are run on platforms that aren't dedicated just for AEM, their
initial state may change between invocations - different OSes may be installed,
which sometimes changes the boot order. To handle this, installation test was
modified to choose proper boot medium automatically, regardless of the default
one.

Writing tests for openQA takes some getting used to, it also requires at least
basic understanding of Perl, because this is the language which openQA uses.
Usually the flow of implementing new test (or part of it) consists of:

- running the test manually, noting _every_ interaction (each key press, mouse
  movement, delay, visual verification of what is displayed)
- writing the notes in test module using [openQA test API](https://open.qa/api/testapi/)
	- key presses become `send_key` or one of the more advanced subroutines like
      `type_string`, `enter_cmd`, `script_run` or even `assert_script_run`,
      depending on expected outcome
	- for raw mouse operations, `mouse_set`, `mouse_click` etc. can be used
	- delays use standard Perl `sleep`, but it is rarely needed
	- video output can be checked by multiple subroutines, most common ones are
      `assert_screen`, `check_screen` and `assert_and_click` - each of those
      take tag as an argument, it must be unique for what it represents, which
      in most cases means a new one has to be used; the screen will be compared
      against so-called needles, they will be created later
- starting the new test using command from one of subdirectories of
  [generalhw](https://github.com/3mdeb/openqa-tests-qubesos/tree/3mdeb-lab/generalhw),
  command for each platform uses different `FLAVOR`
	- one way is to copy new file directly to the worker - not recommended,
      especially if multiple persons can work on tests simultaneously
	- another option is to push it to GitHub repository and start the test with
      [`CASEDIR` and `NEEDLES_DIR` set accordingly](https://open.qa/docs/#_triggering_tests_based_on_an_any_remote_git_refspec_or_open_github_pull_request)
      (remember to use double `%` in `NEEDLES_DIR`, otherwise their preview
      won't work!) - that way fresh tests are cloned to directory specific to
      given platform instead of common one
- open test in web UI and enable developer mode
- wait until if fails on expected needle, and use web UI to define it
	- repeat for each new needle
	- test can be continued after the needle is created
- copy new needles (both PNG and JSON files) and commit to the repository
- rerun the test without enabling developer mode to check if it passes

The above process was repeated for each of the defined configurations. In some
cases needles could be reused (e.g. boot selection menu on the same platform
looks identical, regardless of TPM family), but in others they had to be created
from scratch. After gaining some fluency with test API, the first two steps can
be merged together and performed as one.

### Encountered problems

At first, none of the existing needles for Qubes OS matched the output. It was
caused by wrong order of channels (BGR instead of RGB) due to
[a TC358743 bug](https://github.com/raspberrypi/linux/issues/6068). Previously
it was handled by a patch to `ustreamer`, but since version 6.8 of that program
it is possible to pass `--format-swap-rgb` flag to produce output in correct
format. It seems that the newer version is also more stable, old one required
some tests to be restarted to get a valid output.

Trying to run multiple tests simultaneously showed that our initial idea of
extracting ISO and starting the installer over the network didn't work as
expected. With simultaneous execution and bad timing, newer tests overwrote
Kickstart config file before earlier ones were able to consume it. This was
resolved by starting the installation from storage mounted by PiKVM, separately
for each platform. It also made installation slightly faster.

Unfortunately, SeaBIOS doesn't handle multifunction USB devices too well - it
iterates over all functions, but the loop stops after finding first supported
class (keyboard, mouse or storage). Luckily, the first one exposed by PiKVM is
keyboard, or we would get stuck much earlier. To work around that, as of now
platforms running Dasharo must use regular USB stick with the installer. HP t630
running its original BIOS doesn't have this problem.

Testing also exposed more Dasharo issues, most of which had been resolved:

- TBD links (issues and PRs)

## Installation instructions

TBD: link to trenchboot.org

## Summary

TBD: summary, links to matrix, openqa

Unlock the full potential of your hardware and secure your firmware with the
experts at 3mdeb! If you're looking to boost your product's performance and
protect it from potential security threats, our team is here to help.
[Schedule a call with us](https://calendly.com/3mdeb/consulting-remote-meeting)
or drop us an email at `contact<at>3mdeb<dot>com` to start unlocking the hidden
benefits of your hardware. And if you want to stay up-to-date on all things
firmware security and optimization, be sure to
[sign up for our newsletter](https://3mdeb.com/subscribe/3mdeb_newsletter.html).
Don't let your hardware hold you back, work with 3mdeb to achieve more!
