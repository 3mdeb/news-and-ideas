---
title: ram-wipe againts RAM attacks
abstract: 'This post will introduce some of the very popular attacks that target
electronic devices - the RAM attacks, but the main topic will be the
verification of ram-wipe software solution protection from the attacks.'
cover: /covers/ram-wipe.png
author: daniil.klimuk
layout: post
published: true
date: 2025-04-14
archives: "2025"

tags:
  - RAM
  - wipe
  - Linux
  - dracut
  - warm
  - cold
  - boot
  - attack
categories:
  - Security

---

Hello there! This post will introduce some of the very popular attacks that
target electronic devices - the RAM attacks, but the main topic will be the
verification of [`ram-wipe` software
solution](https://github.com/kicksecure/ram-wipe) protection from the attacks.

## Introduction to RAM attacks

Here the focuse is on two types of attack: cold-boot and warm-boot attacks.

Warm-boot attacks focuse on reading data left in RAM by victim's operating
system or application using attacker's operating system or application without
disconnecting power from the device. For example, rebooting victim's operating
system via `systemctl reboot` (without breaking victim's system execution flow)
and booting some malware to dump or search RAM.

From [`thecyberwire.com`](https://thecyberwire.com/glossary/cold-boot-attack),
a cold boot attack is:

> A side-channel attack in which an attacker with physical access to a device
> retrieves encryption keys after a cold system reboot. A computer is "cold
> booted" when its power is quickly cycled without the machine shutting down
> cleanly or, in some cases, by hitting a reset on the device. See also
> data remanence.

As mentioned above, the key component of this attack is the cold boot, which
appears when a device shuts down due to power loss or when a hardware reset
(aka. hard reset, or the `hitting a reset on the device` from the definition
above) is performed. Then, the device is booted again.

The result of such power loss or hard reset is that the device execution flow
breaks, the tasks that should be executed during a normal shutdown sequence are
not being executed, and everything present in RAM before the shutdown stays
there for a specific for the hardware period of time (that could be extended)
and could be readen.

During such a cold boot, an attacker boots malware or a specific operating
system equipped with tools needed to read RAM and read it, gaining access to
all data and secrets present in RAM before the shutdown. By doing so, the
attacker can get access, among others, to keys that are used to encrypt certain
secrets and file systems.

Below is a graphical representation of the attacks:

![warm-vs-cold-boot-attcks-img](/img/ram-wipe/warm-vs-cold-boot-attack.svg)

Legend:
* Initial state: platform has no power.
* Black arrows: standart boot/power off process.
* Red dashed arrows: malware boot process.
* 1: Platform executing firmware or bootloader code.
* 2: Firmware or bootloader boots operating system or application that
  manipulates secrets in RAM.
* 3: Malware in form of operating system or application that dumps secrets from
  RAM.

The only difference between the attacks is how the malware is being booted
(check the rad dashed arrows): from platform power off state or without powering
off platform.

## ram-wipe

[`ram-wipe`](https://github.com/Kicksecure/ram-wipe#) is a fully software
solution designed by Kicksecure and published under AGPL-3+ license. The goal -
to protect from RAM attacks utilizing GNU/Linux tools. Currently the only
sulution available on the market with the same goal is [Tails Memory
Erasure](https://tails.net/contribute/design/memory_erasure/). Currently
`ram-wipe` is available for test and evaluation, more information could be found
in its [installation](https://www.kicksecure.com/wiki/Ram-wipe) and
[design](https://www.kicksecure.com/wiki/Dev/RAM_Wipe) documentation.

Using `tree` tool inside `ram-wipe` repository shows that `ram-wipe` uses
`dracut` and `systemd`:

```bash
~/Repos/ram-wipe on tags/3.3-1 ● ● λ tree
(...)
├── README.md
└── usr
    ├── lib
    │   ├── dracut
    │   │   ├── dracut.conf.d
    │   │   │   └── 30-ram-wipe.conf
    │   │   └── modules.d
    │   │       ├── 10ram-wipe-exit
    │   │       │   ├── module-setup.sh
    │   │       │   ├── wipe-ram-exit-needshutdown.sh
    │   │       │   └── wipe-ram-exit.sh
    │   │       └── 40cold-boot-attack-defense
    │   │           ├── module-setup.sh
    │   │           ├── wipe-ram-needshutdown.sh
    │   │           └── wipe-ram.sh
    │   ├── systemd
    │   │   └── system
    │   │       └── ram-wipe-kexec-prepare.service
    │   └── tmpfiles.d
    │       └── ram-wipe.conf
    ├── libexec
    │   └── ram-wipe
    │       ├── cold-boot-attack-defense-kexec-prepare
    │       ├── cold-boot-attack-defense-status
    │       └── ram-wipe-lib.sh
    ├── sbin
    │   └── wipe-ram-shutdown-helper
    └── share
        ├── lintian
        │   └── overrides
        │       └── ram-wipe
        └── ram-wipe
            └── placeholder
```

And `file` tool shows that all executables are shell scripts:

```bash
~/Repos/ram-wipe on tags/3.3-1 ● ● λ file $(find ./usr/ -type f)
./usr/lib/dracut/modules.d/10ram-wipe-exit/module-setup.sh:                     Bourne-Again shell script, ASCII text executable
./usr/lib/dracut/modules.d/10ram-wipe-exit/wipe-ram-exit-needshutdown.sh:       POSIX shell script, ASCII text executable
./usr/lib/dracut/modules.d/10ram-wipe-exit/wipe-ram-exit.sh:                    POSIX shell script, ASCII text executable
./usr/lib/dracut/modules.d/40cold-boot-attack-defense/module-setup.sh:          Bourne-Again shell script, ASCII text executable
./usr/lib/dracut/modules.d/40cold-boot-attack-defense/wipe-ram-needshutdown.sh: POSIX shell script, ASCII text executable
./usr/lib/dracut/modules.d/40cold-boot-attack-defense/wipe-ram.sh:              POSIX shell script, ASCII text executable
./usr/lib/dracut/dracut.conf.d/30-ram-wipe.conf:                                ASCII text
./usr/lib/systemd/system/ram-wipe-kexec-prepare.service:                        ASCII text
./usr/lib/tmpfiles.d/ram-wipe.conf:                                             ASCII text
./usr/libexec/ram-wipe/cold-boot-attack-defense-status:                         Bourne-Again shell script, ASCII text executable
./usr/libexec/ram-wipe/ram-wipe-lib.sh:                                         POSIX shell script, ASCII text executable
./usr/libexec/ram-wipe/cold-boot-attack-defense-kexec-prepare:                  Bourne-Again shell script, ASCII text executable
./usr/sbin/wipe-ram-shutdown-helper:                                            Bourne-Again shell script, ASCII text executable
./usr/share/lintian/overrides/ram-wipe:                                         ASCII text
./usr/share/ram-wipe/placeholder:                                               ASCII text
```

Though shell scripts are easy to analyze, the most complicated thing here is to
put all varibles dependencies from the scripts and services that are being
executed in different environments: in Linux during shutdown (`systemd`,
service), inside RAM disk during shutdown and inside RAM disk after booting
second Linux kernel using `kexec`. Because the complexity it is better do
demonstrate its structure via diagrams.

The first diagram demonstrates system boot process:

![ram-wipe-flowchart-1](/img/ram-wipe/ram-wipe-flowchart-1.svg)

<!-- The flowchart above was created by 3mdeb and adheres to ISO-5807. -->

The only thing to note here is the way `ram-wipe` decides whether to run or not
during reboot/poweroff/halt: it checks Linux kernel command line parameter
`wiperam` and then creates a file, that tells `dracut` services to fall back to
RAM disk during reboot/poweroff/halt, where the  first `ram-wipe` stage will
run.

Then, the system mount `rootfs` and switches to userspace:

![ram-wipe-flowchart-2](/img/ram-wipe/ram-wipe-flowchart-2.svg)

<!-- The flowchart above was created by 3mdeb and adheres to ISO-5807. -->

Here `ram-wipe` relies on `ram-wipe-kexec-prepare.service` for setting up the
second stage, and on `dracut-shutdown.service` for getting back to RAM disk and
launching the first `ram-wipe` stage.

After that, the system switches back to RAM disc:

![ram-wipe-flowchart-3](/img/ram-wipe/ram-wipe-flowchart-3.svg)

<!-- The flowchart above was created by 3mdeb and adheres to ISO-5807. -->

Now `ram-wipe` first wipe stage is being launched. The `wiperam` and
`wiperamexit` are Linux kernel command line boot parameters used to skip this
stage (the former one) or prevent `ram-wipe` loop (the later one).

Then, in case the second stage is enabled, `kexec` is being ran during execution
of the first stage, that results in booting to second kernel:

> Note: The first wipe stage before loading Linux kernel via `kexec` checks
> whether secure boot is enabled by `mokutil` tool, so it is possible to run it
> on platforms with Secure Boot protection enabled.

![ram-wipe-flowchart-4](/img/ram-wipe/ram-wipe-flowchart-4.svg)

<!-- The flowchart above was created by 3mdeb and adheres to ISO-5807. -->

This phase wipes the RAM again, but this time during booting the second kernel
when the RAM disk is being mounted first time. After wiping is done - the system
is forced to reboot/powerof/halt (depending on `wiperamaction` Linux kernel
command line parameter) without complete boot.

Now, when the workflow is clear it is important to note two things:
1. Both `ram-wipe` phasses rely on `sdmem` tool, the tool is being called twice
  with the same arguments `-l -l -v` resulting in RAM being overwritten with
  zeroes (`-v` is for verbose). This fact will be used later for testing.
2. `ram-wipe` fully relies on Linux tools and `systemd` services execution
  workflow. This fact will be very important during testing and writing down
  conclusions.

## Testing methodology and tools

As `ram-wipe` is based on setting RAM to zeroes during Linux shutdown or reboot
workflows, to check, whether it succeeded or not the RAM should be checked after
Linux has finished executing. The main problem here is the way the RAM will be
checked. There are two ways: checking the RAM externally, that is, by software
that will not use the wiped RAM for execution (executing software in another RAM
or chip), or by making sure that the software load address and size will be
known, so to be able to conclude what has been overwritten and why some
addresses are not zeroed.

This post will use the second way by executing an EFI application after during
the early device boot stage. The problem with some EFI structures (e.g. logs)
being randomly loaded into RAM was solved by checking, where those structures
are being written before every test. During checking the application record the
addresses in memory modified by firmware and excludes it from dumping.

The application can be found [here](https://github.com/zarhus/ram-dump-efi). It
is a simple application that runs automatically during boot and dumps specified
RAM range values into files. The application was written as minimalistic as
possible to prevent it from modifying RAM.

The final testing methodology using the application is as follows:
1. Boot to the application and choose option 1 to write the pattern.
2. Reboot to the application and choose option 2 to exclude RAM modified by
  firmware.
3. Reboot to OS and run `ram-wipe`.
4. Boot to the application and dump memory.

It **is important** to note, that the booting to the OS was set as automatic
by changing Dasharo firmware boot order. But the application was booted by
chosing the needed drive in `One Time Boot` menu. When bootign the application
by manually choosing the hard drive it **is important to make exaclty the same
steps every time**, that is, making the same amount of keyboard klicks and
visiting the same pages. Otherwise firmware will generate another set of data in
RAM and make the second step from above useless.

After RAM has been dumped its is being analyzed by [a Python
script](https://github.com/zarhus/ram-dump-efi/blob/52042a002672000a730b28c7018afdf04ff15b67/scripts/validate.py)
that checks what adresses where overwritten by zeroes and what addresses still
contain any values. Though this script shows what adresses contain zeroes and
what not, the dumped RAM still will be analyzed in depth manually to check, what
addresses where not wiped and why. To analyze results further the addresses used
by kernels and RAM disks during both stages could be checked via dumping
`/proc/iomem` and analyzing `dmesg` logs. This will give extra inf. why some
addresses swere not zeroed, because `ram-wipe` as a software solution cannot
overwrite kernel address space as well as some other processes address space.

## Testing environment

Requirements for hardware are rather small: the ability to run EFI applications
and as little RAM as possible to reduce the time needed to dump RAM. Because the
`ram-wipe` is a software solution and therefore  does not depend on hardware -
the Qemu with [Dasharo
Firmware](https://docs.dasharo.com/variants/qemu_q35/releases/) is being used
as test platform.

While there is no difference between real platform and Qemu for warm boot
attacks, the real cold boot attack cannot be done on Qemu because Qemu is
software and it could not be reset via power loss and hence the Qemu RAM cells
will not loose its charge as on real platform. In this case the cold boot
attack could be decomposed into two parts: the software execution flow brake and
platform power loss.

The consequence of the software execution flow brake is that everything that is
was going to be executed will not execute. For example: if somebody is watchi a
film - the film will emmidiately stop, if an application wants to wipe its
passwords from RAM - the password will not be wiped, etc.. This is immportant,
because, as was described above, `ram-wipe` is fully software solution and
relies on Linux kernel and `systemd` services execution during
reboot/poweroff/halt. As was described previously it is the key difference
between warm boot and cold boot attacks.

The consequence of the power loss is that all data that was stored in vilotile
memory is going to be lost beacuse of the fact, that vilotile memory relies on
storing its data in cells built up from transistors and capacitors. The loss
means, that after platform lose its power and then is being booted up again, the
valotile memory hold random data insted of what was written to it before power
loss. It is immportant to note, that it takes some time for capacitor to lose
their charge, so the data could be acquired from the vilotile memory if during
short period of time after power loss.

The fact of data loss after platform power loss actually prevents the atacker
from getting all data from RAM. Sometimes the regions that were used to store
secrets will lose their charge faster than other regions, sometimes not. If you
want get more information on why the memory loose its data after power loss and
how long it takes, you should check the series of our blogposts:

* [Research of RAM data remanence
  times](https://blog.3mdeb.com/2024/2024-12-13-ram-data-decay-research/)
* [Research of RAM data remanence times,
  part 2](https://blog.3mdeb.com/2025/2025-01-24-ram-data-decay-research-part2/)
* [Conclusions from RAM data remanence
  tests](https://blog.3mdeb.com/2025/2025-02-20-conclusions-from-ram-data-remanence-tests/)

Because the data loss after platform power loss makes it harder to get data
during cold boot attack, it will be easier to test protection from cold boot
attacks on systems where software execution flow could be broken without loosing
power, so to eliminate randomness of data loss and dump all data from RAM, that
will prove, wether the RAM was wiped by `ram-wipe` or not. Hence Qemu might come
in handy here because it provides [a system_reset
feature](https://www.qemu.org/docs/master/devel/reset.html), that brakes
software execution without reallocating memory for Qemu.

As an operating system, the Debian Trixie test release with encrypted `rootfs`
was used. To install and reproduce the results, follow the following steps:

1. Install Debian Trixie following instructions from [Debian Testing
  article](https://wiki.debian.org/DebianTesting).

2. Migrate to `dracut`:

    ```bash
    $ sudo apt install dracut
    $ sudo dracut -f
    ```

    > Note: If you want to do tests with LUKS on Debian Trixie, **it is
    > important** to do the fith step from [Kicksecire's dracut migration Wiki
    > page](https://www.kicksecure.com/wiki/Dracut#Installation) and then run
    > `sudo dracut -f` again. Otherwise you might end up with LUKS unlokc prompt
    > not showing up during boot.

3. Verify that `dracut` is being used by checking system logs, e.g.:

    ```bash
    $ sudo dmesg | grep dracut
    (...)
    [  OK  ] Finished dracut-initqueue.service - dracut initqueue hook.
    (...)
           Starting dracut-pre-pivot.service - dracut pre-pivot and cleanup hook...
    [  OK  ] Finished dracut-pre-pivot.service - dracut pre-pivot and cleanup hook.
    (...)
    [  OK  ] Stopped dracut-pre-pivot.service - dracut pre-pivot and cleanup hook.
    (...)
    ```

4. Compile and install
[`ram-wipe`](https://github.com/kicksecure/ram-wipe?tab=readme-ov-file#how-to-build-deb-package-from-source-code)
package and its dependency -
[`helper-scripts`](https://github.com/Kicksecure/helper-scripts?tab=readme-ov-file#how-to-build-deb-package-from-source-code):

    ```bash
    $ sudo apt install build-essential debhelper debhelper-compat dh-python\
    dh-apparmor config-package-dev
    $ git clone https://github.com/Kicksecure/helper-scripts.git
    $ cd helper-scripts
    $ git checkout 37a9ef2e84e352e37b7e84bd8ed36e5d31218778
    $ dpkg-buildpackage -b
    $ cd -
    $ sudo apt install ./helper-scripts_31.3-1_all.deb
    $ git clone https://github.com/Kicksecure/ram-wipe.git
    $ cd ram-wipe
    $ git checkout ed9c2978b2c69cebd37b3e1412b648d8f00584e4
    $ dpkg-buildpackage -b
    $ cd -
    $ sudo apt install ./ram-wipe_3.3-1_all.deb
    $ sudo dracut -f
    ```

    > Note: Do not mind the `failed to sign` issues, these will appear if GPG key
    > is not configured properly and is not important here.

5. Verify that `ram-wipe` is being launched during reboot or shutdown by
  checking system logs. For the first stage check for following logs:

    ```bash
    (...)
    [   66.353653] wipe-ram-shutdo (4396): drop_caches: 3
    [   66.359901] dracut INFO: wipe-ram.sh: First RAM wipe pass completed, OK. (1/2)
    [   66.368166] dracut INFO: wipe-ram.sh: Checking if there are still mounted encrypted disks...
    [   66.379157] dracut INFO: wipe-ram.sh: Success, there are no more mounted encrypted disks, OK.
    [   66.388631] dracut INFO: wipe-ram.sh: Now running 'kexec --exec'..
    (...)
    ```

## ram-wipe tests

### Running first stage only

### Running second stage only

### Running both stages

> remove unused categories
> remember about newlines before lists, tables, quotes blocks (>) and blocks of
> text (\`\`\`)
> copy all post images to `blog/static/img` directory. Example usage:

![alt-text](/img/file-name.jpg)

> example usage of asciinema videos:

[![asciicast](https://asciinema.org/a/xJC0QaKuHrMAPhhj5KMZUhMEO.svg)](https://asciinema.org/a/xJC0QaKuHrMAPhhj5KMZUhMEO?speed=1)

> embed responsive YouTube player (copy the address after `v=`):

{{< youtube UQ-6rUPhBQQ >}}

> embed vimeo player (extract the `ID` from the video’s URL):

{{< vimeo 146022717 >}}

> embed Instagram post (you only need the photo’s `ID`):

{{< instagram BWNjjyYFxVx >}}

> embed Twitter post (you need the `URL` of the tweet):

{{< tweet user="3mdeb_com" id="1247072310324080640" >}}

## Summary

Summary of the post.

OPTIONAL ending (may be based on post content):

Unlock the full potential of your hardware and secure your firmware with the
experts at 3mdeb! If you're looking to boost your product's performance and
protect it from potential security threats, our team is here to help.
[Schedule a call with us](https://calendly.com/3mdeb/consulting-remote-meeting)
or drop us an email at `contact<at>3mdeb<dot>com` to start unlocking the hidden
benefits of your hardware. And if you want to stay up-to-date on all things
firmware security and optimization, be sure to
[sign up for our newsletter](https://3mdeb.com/subscribe/3mdeb_newsletter.html).
Don't let your hardware hold you back, work with 3mdeb to achieve more!
